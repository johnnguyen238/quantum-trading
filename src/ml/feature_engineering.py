"""Labeled dataset creation for quantum model training."""

from __future__ import annotations

import logging
from typing import TYPE_CHECKING

import numpy as np

from src.quantum.feature_encoding import FeatureEncoder

if TYPE_CHECKING:
    import pandas as pd

    from src.config.settings import StrategySettings

logger = logging.getLogger(__name__)


class FeatureEngineer:
    """Create labeled datasets from historical OHLCV data.

    Labels are generated by a forward-looking return threshold:
    - LONG (2):  future return > threshold
    - SHORT (0): future return < -threshold
    - NEUTRAL (1): otherwise

    Parameters
    ----------
    settings:
        Strategy configuration for indicator parameters.
    forward_period:
        Number of bars to look ahead for labeling.
    threshold:
        Return threshold for LONG/SHORT classification.
    """

    def __init__(
        self,
        settings: "StrategySettings",
        forward_period: int = 5,
        threshold: float = 0.01,
    ) -> None:
        self._settings = settings
        self._forward_period = forward_period
        self._threshold = threshold

    def create_dataset(
        self,
        df: "pd.DataFrame",
    ) -> tuple[np.ndarray, np.ndarray]:
        """Build features and labels from an OHLCV DataFrame.

        Parameters
        ----------
        df:
            Must contain columns: open, high, low, close, volume.

        Returns
        -------
        Tuple of (features, labels) where features has shape
        ``(n_samples, n_features)`` and labels has shape ``(n_samples,)``.
        """
        if df.empty or len(df) < self._forward_period + 2:
            return np.empty((0, 4)), np.empty((0,), dtype=int)

        encoder = FeatureEncoder(self._settings)
        df_ind = encoder.compute_indicators(df)

        if df_ind.empty or len(df_ind) < self._forward_period + 1:
            return np.empty((0, 4)), np.empty((0,), dtype=int)

        labels = self._generate_labels(df_ind)

        # Encode features (values in [0, 2*pi])
        features = encoder.encode(df_ind)

        # Trim to match: labels lose the last forward_period rows
        n_valid = len(labels)
        features = features[:n_valid]

        # Remove any remaining NaN rows
        mask = np.isfinite(features).all(axis=1) & np.isfinite(labels)
        features = features[mask]
        labels = labels[mask].astype(int)

        logger.info(
            "Created dataset: %d samples, %d features (fwd=%d, thresh=%.4f)",
            len(features),
            features.shape[1] if len(features) > 0 else 0,
            self._forward_period,
            self._threshold,
        )
        return features, labels

    def _generate_labels(self, df: "pd.DataFrame") -> np.ndarray:
        """Generate forward-looking labels.

        Computes the return over the next ``forward_period`` bars.
        Labels:
        - 2 (LONG) if return > threshold
        - 0 (SHORT) if return < -threshold
        - 1 (NEUTRAL) otherwise
        """
        close = df["close"].values
        n = len(close)

        # Forward return: (close[i+period] - close[i]) / close[i]
        future_returns = np.full(n, np.nan)
        for i in range(n - self._forward_period):
            future_returns[i] = (
                (close[i + self._forward_period] - close[i]) / close[i]
            )

        # Classify
        labels = np.full(n, 1, dtype=float)  # default NEUTRAL
        labels[future_returns > self._threshold] = 2  # LONG
        labels[future_returns < -self._threshold] = 0  # SHORT

        # Trim the last forward_period rows (no valid labels)
        labels = labels[: n - self._forward_period]

        return labels
